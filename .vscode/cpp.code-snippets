{
    "fastio": {
        "prefix": "fastio",
        "body": [
            "namespace IO {",
            "\t/* INPUT */",
            "\tchar nc() { return getchar_unlocked(); }",
            "\tvoid rs(string& x) {",
            "\t\tchar ch; x=\"\"; while (isspace(ch = nc()));",
            "\t\tdo { x += ch; } while (!isspace(ch = nc()) && ch != EOF); }",
            "\ttemplate<class T> void ri(T &x) {",
            "\t\tint sgn=1; char ch; x=0;",
            "\t\twhile (!isdigit(ch = nc())) if (ch == '-') sgn *= -1;",
            "\t\tx = ch-'0'; while (isdigit(ch = nc())) x = x*10+(ch-'0');",
            "\t\tx *= sgn; }",
            "\ttemplate<class T, class... Ts> void ri(T& t, Ts&... ts) {",
            "\t\tri(t); ri(ts...); }",
            "\t/* OUTPUT */",
            "\tvoid wc(char ch) { putchar_unlocked(ch); }",
            "\tvoid ws(string& x) { for(char ch : x) wc(ch); }",
            "\ttemplate<class T> inline void wi(T x) {",
            "\t\tif(x < 0) x*=-1, wc('-');",
            "\t\tif(0 <= x && x <= 9) wc('0'+x);",
            "\t\telse wi(x/10), wc('0'+x%10); }",
            "};"
        ],
        "description": "fastio"
    },
    "fileio": {
        "prefix": "fileio",
        "body": [
            "freopen(\"${1:file}.in\", \"r\", stdin);",
            "freopen(\"${1:file}.out\", \"w\", stdout);"
        ],
        "description": "fileio"
    },
    "template-long": {
        "prefix": "template-long",
        "body": [
            "/*",
            "============================================================================",
            " Name:\t\t${1:problem}",
            " Link:\t\t${2:link}",
            " Author:\tDong Liu",
            " Date:\t\t$CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE",
            "============================================================================",
            "*/",
            "",
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "",
            "using ll = long long;",
            "using vi = vector<int>;",
            "using pi = pair<int,int>;",
            "",
            "#define F\t\t\tfirst",
            "#define S\t\t\tsecond",
            "#define SZ(x)\t\tint((x).size())",
            "#define ALL(x)\t\t(x).begin(), (x).end()",
            "#define PB\t\t\tpush_back",
            "#define FOR(i,x,y)\tfor(int i=(x); i<=(y); i++)",
            "#define F0R(i,x)\tFOR(i, 0, (x)-1)",
            "#define ROF(i,x,y)\tfor(int i=(y); i>=(x); i--)",
            "#define R0F(i, x)\tROF(i, 0, (x)-1)",
            "#define EACH(i,x)\tfor(auto& i : (x))",
            "",
            "template<class T> bool ckmin(T& a, const T &b) {",
            "\treturn (b < a ? a = b, 1 : 0); }",
            "template<class T> bool ckmax(T& a, const T &b) {",
            "\treturn (b > a ? a = b, 1 : 0); }",
            "",
            "void dbg() { cerr << endl; }",
            "template<class T, class ...U> void dbg(const T& t, const U&... u) {",
            "\tcerr << ' ' << t; dbg(u...); }",
            "#ifdef LOCAL",
            "\t#define DBG(...) cerr << \"LINE(\" << __LINE__ << \") -> [\" << #__VA_ARGS__ << \"]:\", dbg(__VA_ARGS__)",
            "#else",
            "\t#define DBG(...) 0",
            "#endif",
            "",
            "void IO(string s = \"\") {",
            "\tcin.tie(0)->sync_with_stdio(0);",
            "\tif(SZ(s)) {",
            "\t\tfreopen((s+\".in\").c_str(),\"r\",stdin); ",
            "\t\tfreopen((s+\".out\").c_str(),\"w\",stdout);",
            "\t}",
            "}",
            "",
            "$3",
            "",
            "int main() {",
            "\tIO(\"$4\");",
            "",
            "\t$0",
            "",
            "",
            "}",
            "",
            "/* stuff you should look for",
            "\t* int overflow, array bounds",
            "\t* special cases (n=1?)",
            "\t* do smth instead of nothing and stay organized",
            "\t* WRITE STUFF DOWN",
            "\t* DON'T GET STUCK ON ONE APPROACH",
            "\t* template by bqi343",
            "*/"
        ],
        "description": "template-long"
    },
    "template-short": {
        "prefix": "template-short",
        "body": [
            "/*",
            "============================================================================",
            " Name:\t\t${1:problem}",
            " Link:\t\t${2:link}",
            " Author:\tDong Liu",
            " Date:\t\t$CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE",
            "============================================================================",
            "*/",
            "",
            "#include <iostream>",
            "using namespace std;",
            "",
            "#define N\t(1<<18) // 2e5",
            "",
            "int main() {",
            "",
            "\t$0",
            "}"
        ],
        "description": "template-short"
    },
    "template": {
        "prefix": "template",
        "body": [
            "/*",
            "============================================================================",
            " Name:\t\t${1:problem}",
            " Link:\t\t${2:link}",
            " Author:\tDong Liu",
            " Date:\t\t$CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE",
            "============================================================================",
            "*/",
            "",
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "",
            "using LL = long long;",
            "using VI = vector<int>;",
            "using PI = pair<int, int>;",
            "",
            "#define F\t\t\tfirst",
            "#define S\t\t\tsecond",
            "#define PB\t\t\tpush_back",
            "#define ALL(x)\t\tbegin(x), end(x)",
            "#define SZ(x)\t\tint((x).size())",
            "#define F0R(i,a)\tfor(int i=0; i<(a); i++)",
            "#define FOR(i,a,b)\tfor(int i=(a); i<=(b); i++)",
            "#define R0F(i,a)\tfor(int i=(a)-1; i>=0; i--)",
            "#define ROF(i,a,b)\tfor(int i=(b); i>=(a); i--)",
            "#define EACH(a,x)\tfor (auto& a: x)",
            "",
            "",
            "int main() {",
            "    cin.tie(0)->sync_with_stdio(0);",
            "",
            "    $0",
            "",
            "}"
        ],
        "description": "template"
    },
    "unsync": {
        "prefix": "unsync",
        "body": [
            "cin.tie(NULL);",
            "ios_base::sync_with_stdio(false);"
        ],
        "description": "unsync"
    },
    "BinPow": {
        "prefix": "BinPow",
        "body": [
            "template<class T> binpow(T a, ll b) {",
            "\tif(!b) return 1;",
            "\treturn binpow(a*a, b/2) * (b&1?a:1);",
            "}"
        ],
        "description": "BinPow"
    },
    "Modular": {
        "prefix": "Modular",
        "body": [
            "const int MOD = 1e9+7;",
            "",
            "/* Source: Benq */",
            "struct Modular {",
            "\tT v; explicit operator T() const { return v; }",
            "\tModular() { v = 0; }",
            "\ttemplate<class U> Modular(const U &x) {",
            "        v = (-MOD <= x && x <= MOD) ? x : x % MOD;",
            "        if (v < 0) v += MOD; }",
            "\tfriend ostream& operator<<(ostream& os, const Modular& a) { return os << a.v; }",
            "    friend bool operator==(const Modular& a, const Modular& b) { return a.v == b.v; }",
            "    friend bool operator!=(const Modular& a, const Modular& b) { return !(a == b); }",
            "\tModular operator-() const { return Modular(-v); }",
            "    Modular& operator+=(const Modular& m) { if ((v += m.v) >= MOD) v -= MOD; return *this; }",
            "    Modular& operator-=(const Modular& m) { if ((v -= m.v) < 0) v += MOD; return *this; }",
            "    Modular& operator*=(const Modular& m) { v = (T)v * m.v % MOD; return *this; }",
            "\tfriend Modular exp(Modular a, long long p) { Modular ans(1); ",
            "\t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a; return ans; }",
            "    friend modular inv(const Modular& a) { return exp(a.v, MOD-2); }",
            "\tModular& operator/=(const Modular& m) { return (*this) *= inv(m); }",
            "    friend Modular operator+(Modular a, const Modular& b) { return a += b; }",
            "    friend Modular operator-(Modular a, const Modular& b) { return a -= b; }",
            "    friend Modular operator*(Modular a, const Modular& b) { return a *= b; }",
            "    friend Modular operator/(Modular a, const Modular& b) { return a /= b; }",
            "}",
            "",
            "using mi = Modular<int>;",
            "using vmi = vector<mi>;",
            "using pmi = pair<mi, mi>;",
            "using vmpi = vector<pmi>;"
        ],
        "description": "Modular"
    },
    "LCA": {
        "prefix": "LCA",
        "body": [
            "struct LCA {",
            "\tconstexpr static int U = 30;",
            "\tint N; vector<vi> g, p; vi D; LCA() {}",
            "\tLCA(int N) : N(N), g(N+1), p(N+1), D(N+1)  {}",
            "\tvoid ae(int a, int b) {",
            "\t\tg[a].push_back(b);",
            "\t\tg[b].push_back(a); }",
            "\tvoid dfs(int a, int c, int d) {",
            "\t\tD[a]=d; p[0].push_back(c);",
            "\t\tfor(int b : g[a]) if(b!=c)",
            "\t\t\tdfs(b,a,d+1); }",
            "\tvoid run() { dfs(1,1,0);",
            "\t\tfor(int i=1; i<U; i++) ",
            "\t\tfor(int j=1; j<=N; j++) {",
            "\t\t\tp[j].push_back(p[p[j][i-1]][i-1]); }",
            "\t}",
            "\tint jmp(int a, int d) {",
            "\t\tfor(int i=U-1; i>=0; i--) if(d&(1<<i))",
            "\t\t\ta = p[a][i]; return a; }",
            "\tint lca(int a, int b) {",
            "\t\tif(d[a] < d[b]) swap(a,b);",
            "\t\ta = jmp(a, d[a]-d[b]);",
            "\t\tfor(int i=U-1; i>=0; i--) if(p[a][i] != p[b][i]) {",
            "\t\t\ta=p[a][i]; b=p[b][i]; }",
            "\t\tif(a!=b) a=p[a][0], b=p[b][0]; return a; }",
            "\tint dist(int a, int b) { int c=lca(a,b);",
            "\t\treturn d[a]+d[b]-(2*d[c]); }",
            "};"
        ],
        "description": "LCA"
    },
    "BIT": {
        "prefix": "BIT",
        "body": [
            "template<class T> struct BIT {",
            "\tint N; vector<T> BIT;",
            "\tBIT(int N = 0) : N(N), BIT(N+1) {}",
            "\tT SUM(int POS) {",
            "\t\tT RES = 0;",
            "\t\twhile(POS > 0) {",
            "\t\t\tRES += BIT[POS];",
            "\t\t\tPOS -= POS & (-POS);",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "\tT QUERY(int L, int R) {",
            "\t\treturn SUM(R) - SUM(L-1);",
            "\t}",
            "\tvoid ADD(int POS, T INC) {",
            "\t\twhile(POS < N) {",
            "\t\t\tBIT[POS] += INC;",
            "\t\t\tPOS += POS & (-POS);",
            "\t\t}",
            "\t}",
            "\tvoid UPDATE(int POS, T VAL) {",
            "\t\tADD(POS, VAL - QUERY(POS, POS));",
            "\t}",
            "};"
        ],
        "description": "BIT"
    },
    "LazySeg": {
        "prefix": "LazySeg",
        "body": [
            "template<class T, int DEPTH> struct LAZYSEG {",
            "\tconst int SIZE = 1 << (DEPTH);",
            "\tconst int SEG = SIZE * 2;",
            "\tT TREE[SEG], LAZY[SEG];",
            "\tLAZYSEG() { fill(TREE, TREE+SEG, 0); fill(LAZY, LAZY+SEG, 0); }",
            "\tvoid PUSH(int IDX, int LO, int HI) {",
            "\t\tTREE[IDX] += (HI - LO + 1) * LAZY[IDX];",
            "\t\tif(LO != HI) LAZY[IDX*2] += LAZY[IDX], LAZY[IDX*2+1] += LAZY[IDX];",
            "\t\tLAZY[IDX] = 0;",
            "\t}",
            "\tvoid UPDATE(int L, int R, T INC, int IDX=1, int LO=0, int HI=SIZE-1) {",
            "\t\tPUSH(IDX, LO, HI);",
            "\t\tif(L > HI || R < LO) return;",
            "\t\tif(L <= LO && HI <= R) LAZY[IDX] += INC, push(IDX, LO, HI);",
            "\t\tif(LO == HI) return; int MI = (LO + HI) / 2;",
            "\t\tUPDATE(L, R, INC, IDX*2, LO, MI);",
            "\t\tUPDATE(L, R, INC, IDX*2+1, MI+1, HI);",
            "\t\tTREE[IDX] = TREE[IDX*2] + TREE[IDX*2+1];",
            "\t}",
            "\tT QUERY(int L, int R, int IDX=1, int LO=0, int HI=SIZE-1) {",
            "\t\tPUSH(IDX, LO, HI);",
            "\t\tif(L <= LO && HI <= R) return TREE[IDX];",
            "\t\tif(L > HI || R < LO || LO == HI) return 0;",
            "\t\tint MI = (LO + HI) / 2;",
            "\t\treturn QUERY(L, R, IDX*2, LO, MI) + QUERY(L, R, IDX*2+1, MI+1, HI);\t\t",
            "\t}",
            "};"
        ],
        "description": "LazySeg"
    },
    "SegTree": {
        "prefix": "SegTree",
        "body": [
            "template<class T, int DEPTH> struct SEGTREE {",
            "\tconst int SIZE = 1 << (DEPTH);",
            "\tconst int SEG = SIZE * 2;",
            "\tT TREE[SEG];",
            "\tSEGTREE() { fill(TREE, TREE+SEG, 0); }",
            "\tvoid UPDATE(int INDEX, T VAL, int IDX=1, int LO=0, int HI=SIZE-1) {",
            "\t\tif(LO == HI) { TREE[IDX] = VAL; return; }",
            "\t\tint MI = (LO + HI) / 2;",
            "\t\tif(IDX <= MI) UPDATE(INDEX, VAL, IDX*2, LO, MI);",
            "\t\telse UPDATE(INDEX, VAL, IDX*2+1, MI+1, HI);",
            "\t\tTREE[IDX] = TREE[IDX*2] + TREE[IDX*2+1];",
            "\t}",
            "\tT QUERY(int L, int R, int IDX=1, int LO=0, int HI=SIZE-1) {",
            "\t\tif(L <= LO && HI <= R) return TREE[IDX];",
            "\t\tif(L > HI || R < LO || LO == HI) return 0;",
            "\t\tint MI = (LO + HI) / 2;",
            "\t\treturn QUERY(L, R, IDX*2, LO, MI) + QUERY(L, R, IDX*2+1, MI+1, HI);\t\t",
            "\t}",
            "};"
        ],
        "description": "SegTree"
    },
    "Sparse": {
        "prefix": "Sparse",
        "body": [
            "struct NODE {",
            "\tint VALUE; struct NODE* C[2];",
            "\tNODE() { VALUE = 0; C[0] = C[1] = NULL; }",
            "\tNODE* CHILD(int IDX) {",
            "\t\tif(!C[IDX]) C[IDX] = new NODE();",
            "\t\treturn C[IDX];",
            "\t}",
            "\tvoid UPDATE(int IDX, int VAL, int LO, int HI) {",
            "\t\tif(LO == HI) { VALUE = VAL; return; }",
            "\t\tint MI = (LO + HI) / 2;",
            "\t\tif(IDX <= MI) CHILD(0)->UPDATE(IDX, VAL, LO, MI);",
            "\t\telse CHILD(1)->UPDATE(IDX, VAL, MI+1, HI);",
            "\t\tVALUE = 0;",
            "\t\tif(C[0]) VALUE = VALUE + C[0]->VALUE;",
            "\t\tif(C[1]) VALUE = VALUE + C[1]->VALUE;",
            "\t}",
            "\tT QUERY(int L, int R, int LO, int HI) {",
            "\t\tif(L > HI || R < LO) return 0;",
            "\t\tif(L <= LO || R <= HI || LO == HI) return VALUE;",
            "\t\tint MI = (LO + HI) / 2;",
            "\t\tT RES = 0;",
            "\t\tif(C[0]) RES = RES + C[0]->QUERY(L, R, LO, MI);",
            "\t\tif(C[1]) RES = RES + C[1]->QUERY(L, R, MI+1, HI);",
            "\t}",
            "};"
        ],
        "description": "Sparse"
    },
    "BellmanFord": {
        "prefix": "BellmanFord",
        "body": [
            "template<class T> struct BellmanFord {",
            "\tT U = 1e9; int N; vector<T> d;",
            "\tstruct Edge { T c; int a, b; };",
            "\tvector<Edge> g; BellmanFord() {}",
            "\tBellmanFord(int N) : N(N), d(N+1,U), {}",
            "\tvoid ae(int a, int b, T c) {",
            "\t\tg.push_back({c,a,b}); }",
            "\tvoid run(int src) {",
            "\t\td = vector<T>(N+1,U);",
            "\t\td[src] = 0;",
            "\t\tfor(int i=1; i<N; i++) for(Edge e : g) ",
            "\t\t\td[e.b] = min(d[e.b, d[e.a]+e.c);",
            "\t}",
            "};"
        ],
        "description": "BellmanFord"
    },
    "DSU": {
        "prefix": "DSU",
        "body": [
            "struct DSU {",
            "\tint N; vector<int> D;",
            "\tDSU(int N) : N(N), D(N+1,-1) {}",
            "\tint GET(int x) { return D[x]<0 ? x : D[x]=GET(D[x]); }",
            "\tint SIZE(int x) { return -D[GET(x)]; }",
            "\tbool SAME(int x, int y) { return GET(x) == GET(y); }",
            "\tbool COMB(int x, int y) {",
            "\t\tx=GET(x), y=GET(y); if(x==y) return 0;",
            "\t\tD[x]+=D[y], D[y]=x; return 1; }",
            "};"
        ],
        "description": "DSU"
    },
    "Dijkstra": {
        "prefix": "Dijkstra",
        "body": [
            "template<class T> struct Dijkstra {",
            "\tusing Edge = pair<T, int>; T U = 1e9;",
            "\tvector<vector<Edge>> g; vector<T> d;",
            "\tint N; Dijkstra() {}",
            "\tDijkstra(int N) : N(N), g(N+1), d(N+1) {}",
            "\tvoid ae(int a, int b, T c) {",
            "\t\tg[a].push_back({c,b});",
            "\t\tg[b].push_back({c,a}); }",
            "\tvoid run(int src) {",
            "\t\td = vector<T>(N+1,U); d[src] = 0;",
            "\t\tpriority_queue<Edge> pq; ",
            "\t\twhile(!pq.empty()) { ",
            "\t\t\tEdge e = pq.top(); pq.pop(); ",
            "\t\t\tif(-e.first > e[pq.second]) continue;",
            "\t\t\tfor(Edge c : g[e.first]) {",
            "\t\t\t\tif(-e.first+c.first < d[c.second]) {",
            "\t\t\t\t\td[c.second] = -e.first+c.first;",
            "\t\t\t\t\tpq.push({-e.first-c.first, c.second});",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "}"
        ],
        "description": "Dijkstra"
    },
    "FloydWarshall": {
        "prefix": "FloydWarshall",
        "body": [
            "template<class T> struct FloydWarshall {",
            "\tint N; vector<vector<T>> g; T U = 1e9;",
            "\tFWarshall(int N) : N(N), g(N+1,vector<T>(N+1,U));",
            "\tvoid MIN(T &a, T b) { a = min(a, b); }",
            "\tvoid ae(int a, int b, T c, bool bi=1) {",
            "\t\tMIN(g[a][b],c); if(bi) MIN(g[b][a],c); }",
            "\tvoid run() {",
            "\t\t#define FOR(i,x) for(int i=(1); i<=(x); i++)",
            "\t\tFOR(i,n) MIN(g[a][a], 0);",
            "\t\tFOR(k,n) FOR(i,n) FOR(j,n)",
            "\t\t\tMIN(g[i][j], g[i][k]+g[k][j]);",
            "\t}",
            "\tT dist(int a, int b) { return g[a][b]; }",
            "};"
        ],
        "description": "FloydWarshall"
    },
    "MST": {
        "prefix": "MST",
        "body": [
            "struct DSU {",
            "\tint N; vector<int> D;",
            "\tDSU(int N) : N(N), D(N+1,-1) {}",
            "\tint GET(int x) { return D[x]<0 ? x : D[x]=GET(D[x]); }",
            "\tint SIZE(int x) { return -D[GET(x)]; }",
            "\tbool SAME(int x, int y) { return GET(x) == GET(y); }",
            "\tbool COMB(int x, int y) {",
            "\t\tx=GET(x), y=GET(y); if(x==y) return 0;",
            "\t\tD[x]+=D[y], D[y]=x; return 1; }",
            "};",
            "",
            "template<class T> struct MST {",
            "\tstruct Edge { T c; int a, b; };",
            "\tbool ecmp(Edge a, Edge b) { return a.c < b.c; }",
            "\tint N; DSU D; vector<Edge> E;",
            "\tMST(int N) : N(N), D(N) {}",
            "\tvoid AE(int a, int b, T c) { E.push_back({c,a,b}); }",
            "\tT MST() { sort(begin(E), end(E), ecmp); T r = 0;",
            "\t\tfor(Edge e : E) if (D.COMB(e.a, e.b)) {",
            "\t\t\tr += e.c; } return r; }",
            "};"
        ],
        "description": "MST"
    },
    "SCC": {
        "prefix": "SCC",
        "body": [
            "struct SCC {",
            "\tint N; vector<vi> g, rg;",
            "\tvi td, cmps, cmp; vector<bool> v;",
            "\tSCC(int N) : N(N), g(N+1), rg(N+1), cmp(N+1), v(N+1) {}",
            "\tvoid ae(int x, int y) { g[x].push_back(y), ",
            "\t\trg[y].push_back(x); }",
            "\tvoid t1(int x) { v[x]=1;",
            "        for(int y : g[x]) if(!v[y]) t1(y);",
            "\t\ttd.push_back(x); }",
            "\tvoid t2(int x, int z) { cmp[x]=z;",
            "\t\tfor(int y : rg[x]) if(!cmp[y]) t2(y,z); }",
            "\tvoid scc() {",
            "\t\tfor(int i=1; i<=N; i++) if(!v[i]) t1(i); ",
            "\t\tstd::reverse(td.begin(), td.end());",
            "\t\tfor(int x : td) if(!cmp[x]) { t2(x,x); ",
            "\t\t\tcmps.push_back(x); }",
            "\t}",
            "};",
            ""
        ],
        "description": "SCC"
    },
    "TopoSort": {
        "prefix": "TopoSort",
        "body": [
            "struct TopoSort {",
            "\tint N; vector<vi> g; vi w;",
            "\tTopoSort(int N) : N(N), g(N+1), w(N+1,0) {}",
            "\tvoid ae(int a, int b) { g[a].push_back(b); w[b]++; }",
            "\tvi sort() { queue<int> Q; vi r;",
            "\t\tfor(int i=1; i<=N; i++) if(!w[i]) Q.push(i);",
            "\t\twhile(!Q.empty()) { int a = Q.front(); Q.pop();",
            "\t\t\tr.push_back(a); for(int b : g[a]) if(!--w[b]) {",
            "\t\t\t\tQ.push(b); }",
            "\t\t} return r; }",
            "};"
        ],
        "description": "TopoSort"
    }
}